<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<style>
			
		</style>
	</head>
	<body>
        <!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>


        <!-- Needed to make the import "three" work-->
		<script type="importmap">
			{
				"imports": {
					"three": "../node_modules/three/build/three.module.js"
				}
			}
		</script>

        <!-- Initial loading bar -->
        <div id="gameLoading_bg" style="text-align:center; position: absolute; width: 100%; height: 100%; background-color: rgba(0,0,0,1);">
            <div id="gameLoading_fg" style="text-align:center; position:absolute;     width: 100em; height: auto; margin: 0 auto; padding: 10px; margin-top:20%;  position: relative; ">
                <label id="gameLoading_label" style=" font-size: 3em; color:white;" for="gameLoading_fb_bar">Loading in progress:</label><br>
                <progress  id="gameLoading_fg_bar" style="width: 100em; height: 3em;" max="100" ></progress>
            </div>
        </div>

		<script type="module">
        import * as THREE from '../node_modules/three/build/three.module.js';
        import { OrbitControls } from '../node_modules/three/examples/jsm/controls/ModifiedOrbitControls.js';
		import * as CANNON from '../node_modules/cannon-es/dist/cannon-es.js';
		import {GLTFLoader} from '../node_modules/three/examples/jsm/loaders/GLTFLoader.js';
		import { TWEEN } from '../node_modules/three/examples/jsm/libs/tween.module.min.js'
		import { Sky } from '../node_modules/three/examples/jsm/objects/Sky.js';

		var gameLoaded = false;
		var animateScene = false;
		var relDir=0;
		var playerState = "Idle";
		var cameraTarget = new THREE.Vector3();
		var mixer;
		var archerModel, archerModelParent;
		var arrowModel, targetModel, targetModel1, targetModel2,targetModel3, targetModel4;
		var targetModelParent1, targetModelParent2, targetModelParent3, targetModelParent4;
		var archerStructure = {};
		var canShoot=true;
		var lastExecutedAnimation = "Idle";
		var idle, idleB, runA, runB, runC, runD, jumpA, jumpB, walkA, walkB, walkC, walkD, shootPre, shootA, shootB, shootC, targetMovement1, targetMovement2, targetMovement3, targetMovement4, level2Unlock, level3Unlock1, level3Unlock2, level3Unlock3, level3Unlock4, level3Unlock5, level3Unlock6;
		var backObsPlat1, fwdObsPlat1, backObsPlat2, fwdObsPlat2, backObsPlat3, fwdObsPlat3;
		var arrows =[];
		var target1hit = false, target2hit = false, target3hit=false, target4hit=false;
		var prevPlayerPosition;
		var obsPlatTweens = [];
		var obsPlat=[];
		var robots=[];
		var robotsTweens = [];
		var oldx = 0, oldz = 0, oldy = 10;
		var cameraAngle, desQuat;
		var rotatingPlatModel;
		var rotatePlatFloatingTweens =[];
		var skyboxModel, mainPlatModel, groundPlatModelParent, level2PlatformModelParent, level3PlatformModelParent;
		var pause_bg = document.getElementById("pause_bg");
		var pause_fg = document.getElementById("pause_fg");
		var justRepulsedArcher = false;
		var arrowAnimation, archerRightHand;
		var bombs = [];
		var bombModel;
		var justShotCannon1 = false;
		var cannonBody, cannonModel, cannonModelParent, cannonMesh;
		var slModel, slModelParent;
        var targetBody1,targetMesh1, targetModelParent1;
        var targets=[];
        var targetSpeed = 0.0005;
        var targetRotation = 0.00001;
        var horizontalMax = 20;
        var verticalMax = 50;
        var generatingStep = 4;
        var targetsDepth = 20;
		var addedTarget = 0;

        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        function onPointerClick( event ) {

            // calculate pointer position in normalized device coordinates
            // (-1 to +1) for both components

            pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

            // update the picking ray with the camera and pointer position
            raycaster.setFromCamera( pointer, camera );

            // calculate objects intersecting the picking ray
            const intersects = raycaster.intersectObjects( scene.children );

            if(intersects[0]){
                targets.forEach(element => {
                    if(element["mesh"] == intersects[0].object){
                        element["body"].mass = 100;
                        element["body"].updateMassProperties();
                    }
                });
            }

        }

        window.addEventListener( 'pointerdown', onPointerClick );



		//CANNON AND THREE SETUP
		const world = new CANNON.World({
			gravity: new CANNON.Vec3(0, -20, 0)
		});

		const scene = new THREE.Scene();
		// scene.background = new THREE.Color( 0x00C0F0 );
		
		var sky = new Sky();
		sky.scale.setScalar( 450000 );
		scene.add( sky );
		var sunPosition = new THREE.Vector3();

		sky.material.uniforms[ 'turbidity' ].value =20;
		sky.material.uniforms[ 'mieCoefficient' ].value =0;
		sky.material.uniforms[ 'mieDirectionalG' ].value =1;
		sky.material.uniforms[ 'rayleigh' ].value =0.05;
		sunPosition.setFromSphericalCoords( 1, THREE.MathUtils.degToRad( 90 - 45 ), THREE.MathUtils.degToRad( 90 ) );
		sky.material.uniforms[ 'sunPosition' ].value.copy( sunPosition );

		const camera = new THREE.PerspectiveCamera(
			45,
			window.innerWidth / window.innerHeight,
			0.1,
			1000
			);
			
			
			const renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.shadowMap.enabled = true;
			document.body.appendChild( renderer.domElement );
			renderer.toneMappingExposure = 0.5;
			
			camera.position.set(0,0,-5);
			camera.quaternion.setFromAxisAngle(new CANNON.Vec3(0,1,0), Math.PI);


		
		//LIGHT SETUP

		const ambLight = new THREE.AmbientLight(0xFFFFFF, 1);
		scene.add(ambLight);
		
		const dirLight = new THREE.DirectionalLight(0xFFFFFF, 10);
		dirLight.position.set(0, 50, -5);
		dirLight.target.position.set(0, 0, 20);
		dirLight.castShadow = true; 
		dirLight.shadow.camera.left = - 200;
		dirLight.shadow.camera.right = 15;
		dirLight.shadow.camera.top = 15;
		dirLight.shadow.camera.bottom = - 15;
		dirLight.shadow.camera.far = 100;
		dirLight.shadow.bias = - 0;
		dirLight.shadow.mapSize.width = Math.pow(2,12); // default
		dirLight.shadow.mapSize.height = Math.pow(2,12); // default
		scene.add(dirLight);
		scene.add(dirLight.target);

		//CUBE (THREE)

		
		const loadingManager = new THREE.LoadingManager();
        const gltfLoader = new GLTFLoader(loadingManager);
		loadingManager.onLoad = () => {gameLoaded = true; document.querySelector('#gameLoading_fg').style.display = 'none'; document.querySelector('#gameLoading_bg').style.display = 'none';};
		loadingManager.onProgress = (url, itemsLoaded, itemsTotal) => {
			document.querySelector('#gameLoading_fg_bar').setAttribute("value",`${itemsLoaded / itemsTotal * 100 | 0}`);
		};

		

        var positions = [];
        for(var i = 0 ; i <= (horizontalMax*2) / generatingStep; i++){
            for(var j = 0 ; j <= (verticalMax*2) / generatingStep; j++){
                positions.push(new THREE.Vector3( - horizontalMax + generatingStep * i, - verticalMax + generatingStep * j, targetsDepth));
            }
        }

		gltfLoader.load("gltf/skybox/scene.gltf", (gltf) => {
			skyboxModel = gltf.scene.getObjectByName("Sketchfab_Scene");
			skyboxModel.scale.setScalar( 1 );
			//Removing the sky (it causes issues with directional light)
			var sky= gltf.scene.getObjectByName("hoth_sky");
			sky.visible=false;
			skyboxModel.traverse( function( node ) {
				if (node.isMesh) { 
					node.castShadow = true;
					node.receiveShadow=true;
					node.frustumCulled=true;
			}
			} );
			scene.add(skyboxModel);
			skyboxModel.rotation.y = -0.50;
		});

		gltfLoader.load("gltf/target/scene.gltf", (gltf) => {
			targetModel = gltf.scene.getObjectByName("Sketchfab_Scene");
			targetModel.scale.setScalar( 0.3 );

			
			gltf.scene.traverse( function( node ) {
				if (node.isMesh) { 
					node.castShadow = true;
					node.receiveShadow=true;
					node.frustumCulled=false;
			}
			} );


            for(var i=0; i<positions.length; i++){
               createTarget(positions[i]);
            }
		});

	function createTarget(position){
        var genTargetModelParent = new THREE.Object3D();
        var genTargetModel = targetModel.clone();
        genTargetModel.getWorldPosition(genTargetModelParent.position);
        genTargetModel.rotation.set(...[Math.PI/2,0,0]);
        genTargetModelParent.add(genTargetModel);
		genTargetModelParent.position.set(position);
        scene.add(genTargetModelParent);

        var genTargetBody = new CANNON.Body({
            shape: new CANNON.Cylinder(1,1,0.5,10),
            position: position,
            type : CANNON.Body.DYNAMIC,
            mass:0
        });
        var genTargetMesh = new THREE.Mesh( new THREE.CylinderGeometry( 1, 1, 0.5, 10 ), new THREE.MeshPhongMaterial( { color: 0x00ff00, wireframe: true, opacity : 0, transparent: true} ) );
		genTargetMesh.position.set(position);
        scene.add(genTargetMesh);
		genTargetMesh.material.opacity=0;
        world.addBody(genTargetBody);		
        genTargetBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),Math.PI/2);

        targets.push({"body" : genTargetBody, "mesh" : genTargetMesh, "model" : genTargetModelParent})
    }



		const time = new THREE.Clock();
		var deltaTime = 0;
		var elapsedTime = 0;
		function animate() {
			deltaTime = time.getDelta();
			if(animateScene == false){
				elapsedTime = time.getElapsedTime() * 1000;
				TWEEN.update();
				world.step(1/60,deltaTime,10);

				if(targets[0])
					addedTarget += (deltaTime * 1000 * targetSpeed);
				
				if(skyboxModel){
					skyboxModel.rotation.y -= (deltaTime * 1000 * targetRotation);
					console.log(skyboxModel.rotation.y)
				}
								

				targets.forEach(element => {
					element["body"].position.x -= (deltaTime * 1000 * targetSpeed);

                    element["model"].position.copy(element["body"].position);
					element["model"].quaternion.copy(element["body"].quaternion);
					element["mesh"].quaternion.copy(element["body"].quaternion);
					element["mesh"].position.copy(element["body"].position);

					//Check if the target is falling down or out of scene
					if(element["body"].position.y < -verticalMax || element["body"].position.x < -horizontalMax){
							scene.remove(element["model"]);
							setTimeout(function() {
								world.removeBody(element["body"]);
							},0);
							scene.remove(element["mesh"]);
							targets = targets.filter(function(ele){ 
								return ele != element; 
							});
						}
                });

				if(addedTarget > generatingStep){
					var newPositions =[];
					for(var j=0; j<(verticalMax*2)/generatingStep; j++){
						newPositions.push(new THREE.Vector3(horizontalMax, - verticalMax + j * generatingStep, targetsDepth));
					}
					for(var i=0; i<newPositions.length; i++){
						createTarget(newPositions[i]);
					}
					addedTarget = 0;
				}
   
            }


			renderer.render( scene, camera );

			requestAnimationFrame(animate);
		};

		requestAnimationFrame(animate);

		function dumpObject(obj, lines = [], isLast = true, prefix = '') {
            const localPrefix = isLast ? '└─' : '├─';
            lines.push(`${prefix}${prefix ? localPrefix : ''}${obj.name || '*no-name*'} [${obj.type}]`);
            const newPrefix = prefix + (isLast ? '  ' : '│ ');
            const lastNdx = obj.children.length - 1;
            obj.children.forEach((child, ndx) => {
                const isLast = ndx === lastNdx;
                dumpObject(child, lines, isLast, newPrefix);
            });
            return lines;
        }

		</script>
	</body>
</html>